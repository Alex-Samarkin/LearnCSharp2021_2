using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Tut5
{
    internal class Program
    {
        static void Main(string[] args)
        {
            /// Существует много (плюс-минус стандартных) структур хранения данных
            /// массивы, списки, множества, словари, очереди, стеки,деревья, хеш таблицы
            /// в общем, они реализуют одни и те же функции независимо от того,
            /// какие именно (какого типа) в них хранятся
            /// 
            /// в Python ряд таких структур встроен в язык
            /// это списки, туплы, словари
            /// вместе с тем, многие структуры данных в язык не вошли
            /// весте с тем, эти структуры не типизированы (обычно в них может быть все, 
            /// что нужно программисту, это снижает скорость работы со структурами и усложняет логику работы
            /// 
            /// одно из решений - дженерики
            /// дженерики - это обобщенные структуры данных, например, список - List
            /// он реализован так, что использует "какой-то" тип данных для хранения
            /// при использовании, вместо неопределенного типа подставляется конкретный
            /// например List<int> - список целых чисел
            /// 
            /// обратите внимание: using System.Collections.Generic; - подключает дженерики
            /// дженерики чуть медленне, но гораздо более надежные и удобные
            /// почти всегда следует использовать дженерики
            /// 

            /// создадим список для целых чисел и повторим с ним операции предыдущей работы
            /// 

            /// дженерик - это класс, создается оператором new
            /// здесь создается список целых чисел, но ни одного числа пока в списке нет
            List<int> vs = new List<int>();

            int N = 1500; // длина массива
            int From = 0; // границы массива по величине
            int To = 101;

            var r = new Random(); // генератор случайных чисел

            /// заполняем массив случайными числами 
            for (int i = 0; i < N; i++)
            {
                vs.Add(r.Next(From, To)); // именно Add
            }

            /// печатаем элементы массива в строку
            /// 
            /// цикл foreach просто перебирает все элементы в массиве, 
            /// это проще и безопаснее, чем считать длину
            foreach (var item in vs)
            {
                Console.Write($"{item,6}, ");
            }
            Console.ReadLine();

            /// печатаем массив в строку вместе с номером элемента
            /// количество элементов в списке - Count
            /// емкость списка на текущий момент - Capacity
            ///
            for (int i = 0; i < vs.Count; i++)
            {
                Console.WriteLine($"| {i,6} | {vs[i],8} |");
            }
            Console.ReadLine();

            /// тоже, но в цикле foreach
            /// обычно это лучший выбор
            int j = 0;
            foreach (var item in vs)
            {
                Console.WriteLine($"| {j,6} | {vs[j],8} |");
                j++;
            }
            Console.ReadLine();

        }
    }
}
